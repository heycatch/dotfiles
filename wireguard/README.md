Инструкция к Debian >= **12** версии. \
Это означает, что на вторую половину **2024** года эти версии нуждаются в включении *backports* для стабильных пакетов. \
В документации можно увидеть пометку об [этом](https://www.wireguard.com/install/). \
Для особо тупых: переместить файл **bookworm-backports.list** на сервер в папку */etc/apt/sources.list.d/*.

Но можно и пропустить это предисловие, на домашней пустой впс'ке ничего страшного не произойдет. \
Инструкция подойдет и для Ubuntu.

```bash
# Устновка нужных пакетов.
apt update && apt upgrade -y
apt install wireguard ufw

# Конфигурация wg на стороне сервера. Пример конфига(wg0.conf) можно посмотреть в текущей папке.
cd /etc/wireguard/ && touch wg0.conf
wg genkey | tee privatekey | wg pubkey | tee publickey
# Конфигруация wg на стороне клиента. Пример конфига(wg1.conf) можно посмотреть в текущей папке.
# Здесь уже убраны повторения на генерацию ключей и предоставлен конфиг и как он должен выглядеть.
# P.S. DNS нужно указывать для приложения на виндовс/эпл, а на линуксе/андроиде нет.

# Раскомментировать строчку net.ipv4.ip_forward = 1 в /etc/sysctl.conf и проверить.
sysctl -p

# Wg работает только по udp. Открываем нужный порт указанный в конфиге.
# 22 нужен для ssh.
ufw enable
ufw allow 22/tcp
ufw allow 1337/udp
ufw status # Проверить все порты.
# Убираем доступ к определенному порту.
ufw status numbered # Находим нужную цифру.
ufw delete 1 # Заменить на свою цифру.
ufw reload
ufw status # Проверить все порты.

# Немного о wg0.conf:
# 1) Строка у сервера с Address имеет маску подсети /24 = 2^8 = 256 адресов.
# 10.0.0.0/24 зарезервирован(network address), как и 10.0.0.255/24 (broadcast address).
# Поэтому начинать нужно с 10.0.0.1/24.
# Для домашнего использования хватит и /28 = 2^4 = 16 или /29 2^3 = 8 адресов.
# Тут уже зарезервированы 10.0.0.0/28, 10.0.0.15/28 и 10.0.0.0/29, 10.0.0.7/29.
# Для клиента хватает и подмаски /32 - 1 адрес, ведь подключение у нас с сервером через point-to-point.
# И адрес для клинта, офк, не зарезервирован.
# 2) SaveConfig = true сохраняет настройки при останоке/перезапуске сетевого интерфейса.
# 3) Строки с PostUp(выполняется команда автоматически при запуске)/PostDown(выполняется команда автоматически при остановке)
# управляют правилами брендмауера iptables, а имя сетевого интерфейса eth0 нужно заменить на свое.
# Узнать его можно с помощью команды ip addr. Не путать имена всяких локалок(lo), докеров(docker0) и etc.
# В кратце строки устанавливают/удаляют правила для брендмауэра, чтобы перенаправлять трафик клиента через внешний интерфейс,
# используя NAT для маскироваки айпи адресов. Обязательные строки для выхода за границы туннеля.

# Запускаем сервис.
systemctl enable wg-quick@wg0
systemctl start wg-quick@wg0
systemctl status wg-quick@wg0 # Проверить сервис.

# Посмотреть запущенные интерфейсы.
wg
# Или... будет без разницы.
wg show

# При добавлении нового пользователя нужно остановить службу.
wg-quick down wg0
# Обновляем конфиг в /etc/wireguard/wg0.conf и после запускаем.
wg-quick up wg0

# Если нужно удалить сетевой интерфейс.
ip link delete dev wg0
ip addr # Проверить отсутствие.

# Запуск на клиенте (Debian).
# Перенести конфиг в /etc/wireguard/.
sudo wg-quick up wg1
sudo wg-quick down wg1

# === Ограничение трафика ===
# Нужно понимать, что wg - это туннельный протокол и не управляет
# пропускной способностью. Поэтому мы будем использовать встроенную утилиту tc.

# Настройки tc после перезапуска будут утерены, поэтому нужно сделать
# инициализирующий скрипт при запуске системы, я работаю с systemd.
systemctl enable wg0-bandwidth.service
systemctl start wg0-bandwidth.service
systemctl status wg0-bandwidth.service # Проверяем сервис.

# Теперь разберем саму утилиту tc и ее параметры. Это строчки ExecStart.
# 1) Но перед этим уточним путь утилиты. Она может находиться в /usr/bin/tc, но,
# чаще всего по правилам в /usr/sbin/tc. Сам путь можно узнать командой ниже.
whereis tc
# 2) Теперь наконец-то разберем утилиту:
# qdisc(queuening discipline) - это механизм ядра Linux, который управляет
# очередью сетевых пакетов(отправляемых и получаемых сетевым интерфейсом).
# tbf(token bucket filter) - это алгоритм управления очередью сетевых пакетов.
# rate 10mbit - это ограничение скорости до 10Мбит/с.
# burst 15k - это размер буфера. Это позволяет небольшим пикам скорости
# проходить без дросселирования.
# latency 50ms - это минимальное время, которе пакет должен пробыть в очереди,
# прежде чем будет отправлен.

# С параметрами rate|burst|latency нужно индивидуально разбираться для достижения
# оптимальных настроек, чтобы не вызвать, например, постоянную высокую нагрузку процессора.
```
